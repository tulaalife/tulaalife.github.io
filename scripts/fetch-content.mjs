// Node ESM build-time script
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { createClient } from '@supabase/supabase-js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ---- Config
const TABLES = {
    plans: 'plans',
    audios: 'guided_audio_sessions',
    tips: 'health_tips',
    posts: 'posts', // <--- NEW
};
const N_TIPS = 10; // homepage slice size

const { PREVIEW_VISIBILITIES = 'public' } = process.env;
const ALLOWED_VIS = PREVIEW_VISIBILITIES.split(',').map(s => s.trim()).filter(Boolean);

// ---- Helpers
const teaser = (s, max = 160) => {
    if (!s) return '';
    const t = String(s).replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
    if (t.length <= max) return t;
    const cut = t.slice(0, max + 1);
    const idx = cut.lastIndexOf(' ');
    return (idx > 0 ? cut.slice(0, idx) : cut.slice(0, max)).trim() + '…';
};

const toAbs = (s) => (s ?? '').toString().trim();
const ensureHttps = (u) => (u && /^https?:\/\//i.test(u) ? u : '');

const outBanner = (ts) => `// AUTO-GENERATED FILE. DO NOT EDIT.
// Generated by scripts/fetch-content.mjs during CI.
// This file is intentionally not committed.
${ts}
`;

// Deterministic daily shuffle so builds are stable within a day (UTC)
const seededShuffle = (arr, seed) => {
    const a = arr.slice();
    let x = seed || 1;
    const rand = () => {
        x ^= x << 13; x ^= x >>> 17; x ^= x << 5;
        return (x >>> 0) / 0xffffffff;
    };
    for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(rand() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
};

// ---- Supabase client (service key in CI only; never in browser)
const { SUPABASE_URL, SUPABASE_SERVICE_KEY } = process.env;
if (!SUPABASE_URL || !SUPABASE_SERVICE_KEY) {
    console.error('[fetch-content] Missing SUPABASE_URL / SUPABASE_SERVICE_KEY in env');
    process.exit(1);
}
const sb = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY, { auth: { persistSession: false } });

// ---- Loads
async function loadPlans() {
    const { data, error } = await sb
        .from(TABLES.plans)
        .select('slug,title,subtitle,description,insights,image_url,visibility')
        .in('visibility', ALLOWED_VIS)
        .not('slug', 'is', null)
        .order('title', { ascending: true });

    if (error) throw error;

    return (data ?? []).map((r) => {
        let benefits = '';
        try {
            if (Array.isArray(r.insights)) {
                const parts = r.insights.map((it) =>
                    typeof it === 'string' ? it : (it?.text ?? it?.title ?? it?.value ?? '')
                ).filter(Boolean);
                benefits = parts.join(' · ').slice(0, 240);
            }
        } catch { }
        return {
            slug: toAbs(r.slug),
            title: toAbs(r.title),
            subtitle: toAbs(r.subtitle),
            teaser: teaser(r.description),
            benefits,
            image: ensureHttps(toAbs(r.image_url)),
            deeplink: `tulaa://app/yoga/${toAbs(r.slug)}`,
        };
    }).filter(p => p.slug && p.image);
}

async function loadAudios() {
    const { data, error } = await sb
        .from(TABLES.audios)
        .select('slug,title,subtitle,description,image_url,updated_at')
        .not('slug', 'is', null)
        .not('image_url', 'is', null)
        .order('title', { ascending: true });

    if (error) throw error;

    return (data ?? []).map((r) => ({
        slug: toAbs(r.slug),
        title: toAbs(r.title),
        subtitle: teaser(r.subtitle),
        teaser: teaser(r.description),
        image: ensureHttps(toAbs(r.image_url)),
        deeplink: `tulaa://app/audio/${toAbs(r.slug)}`,
    })).filter(a => a.slug && a.image);
}

// ✅ Return ALL tips (no slicing here)
async function loadAllTips() {
    const { data, error } = await sb
        .from(TABLES.tips)
        .select('slug,tip,benefit,precaution,category,icon,updated_at')
        .not('slug', 'is', null)
        .order('slug', { ascending: true });

    if (error) throw error;

    return (data ?? []).map((r) => ({
        slug: toAbs(r.slug),
        tip: toAbs(r.tip),
        benefit: toAbs(r.benefit),
        precaution: toAbs(r.precaution),
        category: toAbs(r.category),
        icon: toAbs(r.icon),
        deeplink: `tulaa://app/tips/${toAbs(r.slug)}`,
    })).filter(t => t.slug && t.tip && t.benefit);
}

// ✅ NEW: Load Blog Posts
async function loadPosts() {
    // Select all fields needed for SEO, Index listing, AND the detailed content page.
    const { data, error } = await sb
        .from(TABLES.posts)
        .select(`
            slug, title, excerpt, cover_image_url, 
            status, published_at, language, 
            seo_title, seo_description, 
            content, goal_ids, suitable_time_of_day,
            cta_link, cta_text
        `)
        .eq('status', 'published') // Only fetch published posts
        .not('slug', 'is', null)
        .order('published_at', { ascending: false }); // Newest first

    if (error) throw error;

    return (data ?? []).map((r) => {
        // Fallback Logic:
        // 1. Title: Use seo_title if present, else title
        // 2. Desc: Use seo_description, else excerpt, else auto-generated teaser from excerpt
        const metaTitle = r.seo_title || r.title;
        const metaDesc = r.seo_description || r.excerpt || '';

        return {
            slug: toAbs(r.slug),
            language: r.language || 'en',
            title: toAbs(r.title),
            excerpt: toAbs(r.excerpt),
            image: ensureHttps(toAbs(r.cover_image_url)),
            date: r.published_at, // Keep as ISO string for Astro to format

            // Meta / SEO pre-calculated
            metaTitle: toAbs(metaTitle),
            metaDescription: toAbs(metaDesc),

            // Content & Actions
            content: r.content, // Pass the JSONB through
            cta: (r.cta_link && r.cta_text) ? { link: r.cta_link, text: r.cta_text } : null,

            // Tags
            goals: r.goal_ids || [],
            timeOfDay: r.suitable_time_of_day || [],
        };
    });
}

// ---- Emit
function toTsArray(varName, arr) {
    const json = JSON.stringify(arr, null, 2);
    return `export const ${varName} = ${json} as const;`;
}

async function run() {
    const [plans, audios, tipsAll, posts] = await Promise.all([
        loadPlans(),
        loadAudios(),
        loadAllTips(),
        loadPosts(), // <--- NEW
    ]);

    // homepage selection stays limited & daily-shuffled
    const daySeed = Number(new Date().toISOString().slice(0, 10).replaceAll('-', ''));
    const tips = seededShuffle(tipsAll, daySeed).slice(0, N_TIPS);

    // Note: You might need to add 'BlogPost' to your types definition file
    const ts = `import type { YogaPlanPreview, GuidedAudioPreview, TipPreview } from './types';

${toTsArray('yogaPlans', plans)}
${toTsArray('guidedAudios', audios)}
${toTsArray('tips', tips)}           // homepage: limited
${toTsArray('allTips', tipsAll)}     // detail pages: FULL set
${toTsArray('blogPosts', posts)}     // blog pages: FULL set
`;

    const outDir = path.join(__dirname, '..', 'src', 'data');
    fs.mkdirSync(outDir, { recursive: true });
    fs.writeFileSync(path.join(outDir, 'generated.ts'), outBanner(ts), 'utf8');

    console.log(
        `[fetch-content] Wrote src/data/generated.ts with ${plans.length} plans, ${audios.length} audios, ${tipsAll.length} tips & ${posts.length} posts.`
    );
}

run().catch((e) => {
    console.error('[fetch-content] ERROR:', e);
    process.exit(1);
});