// Node ESM build-time script
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { createClient } from '@supabase/supabase-js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ---- Config
const TABLES = {
    plans: 'plans',
    audios: 'guided_audio_sessions',
    tips: 'health_tips',
};
const N_TIPS = 10; // expose only this many tips

// Allow showing 'testing' items on non-production if you want.
// e.g. PREVIEW_VISIBILITIES="public,testing"
const { PREVIEW_VISIBILITIES = 'public' } = process.env;
const ALLOWED_VIS = PREVIEW_VISIBILITIES.split(',').map(s => s.trim()).filter(Boolean);

// ---- Helpers
const teaser = (s, max = 160) => {
    if (!s) return '';
    const t = String(s).replace(/<[^>]*>/g, ' ') // strip HTML if any
        .replace(/\s+/g, ' ')
        .trim();
    if (t.length <= max) return t;
    const cut = t.slice(0, max + 1);
    const idx = cut.lastIndexOf(' ');
    return (idx > 0 ? cut.slice(0, idx) : cut.slice(0, max)).trim() + '…';
};

const toAbs = (s) => (s ?? '').toString().trim();
const ensureHttps = (u) => (u && /^https?:\/\//i.test(u) ? u : '');

const outBanner = (ts) => `// AUTO-GENERATED FILE. DO NOT EDIT.
// Generated by scripts/fetch-content.mjs during CI.
// This file is intentionally not committed.
${ts}
`;

// Deterministic daily shuffle so builds are stable within a day (UTC)
const seededShuffle = (arr, seed) => {
    const a = arr.slice();
    let x = seed || 1;
    const rand = () => {
        x ^= x << 13; x ^= x >>> 17; x ^= x << 5;
        return (x >>> 0) / 0xffffffff;
    };
    for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(rand() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
};

// ---- Supabase client (service key in CI only; never in browser)
const { SUPABASE_URL, SUPABASE_SERVICE_KEY } = process.env;
if (!SUPABASE_URL || !SUPABASE_SERVICE_KEY) {
    console.error('[fetch-content] Missing SUPABASE_URL / SUPABASE_SERVICE_KEY in env');
    process.exit(1);
}
const sb = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY, { auth: { persistSession: false } });

// ---- Loads
async function loadPlans() {
    // visibility exists on plans table (enum tulaa_visibility)
    const { data, error } = await sb
        .from(TABLES.plans)
        .select('slug,title,subtitle,description,insights,image_url,visibility')
        .in('visibility', ALLOWED_VIS)
        .not('slug', 'is', null)
        .order('title', { ascending: true });

    if (error) throw error;

    return (data ?? []).map((r) => {
        // insights is jsonb array; coerce to a short bullet-like line
        let benefits = '';
        try {
            if (Array.isArray(r.insights)) {
                // items may be strings or objects; pick text/value/title sensibly
                const parts = r.insights.map((it) =>
                    typeof it === 'string'
                        ? it
                        : (it?.text ?? it?.title ?? it?.value ?? '')
                ).filter(Boolean);
                benefits = parts.join(' · ').slice(0, 240);
            }
        } catch (_) { }

        return {
            slug: toAbs(r.slug),
            title: toAbs(r.title),
            subtitle: toAbs(r.subtitle),
            teaser: teaser(r.description),
            benefits,
            image: ensureHttps(toAbs(r.image_url)),
            deeplink: `tulaa://yoga/${toAbs(r.slug)}`,
            // locale intentionally omitted (column not present in schema provided)
        };
    }).filter(p => p.slug && p.image);
}

async function loadAudios() {
    // No 'published' or 'visibility' in provided DDL; use conservative gates
    const { data, error } = await sb
        .from(TABLES.audios)
        .select('slug,title,description,image_url,updated_at')
        .not('slug', 'is', null)
        .not('image_url', 'is', null)
        .order('title', { ascending: true });

    if (error) throw error;

    return (data ?? []).map((r) => ({
        slug: toAbs(r.slug),
        title: toAbs(r.title),
        teaser: teaser(r.description),
        image: ensureHttps(toAbs(r.image_url)),
        deeplink: `tulaa://audio/${toAbs(r.slug)}`,
    })).filter(a => a.slug && a.image);
}

async function loadTips() {
    // No 'published' in health_tips; gate by slug presence.
    // ❗ Do NOT select source_name/source_url to avoid leaking sources.
    const { data, error } = await sb
        .from(TABLES.tips)
        .select('slug,tip,benefit,precaution,category,icon,updated_at')
        .not('slug', 'is', null)
        .order('slug', { ascending: true });

    if (error) throw error;

    const all = (data ?? []).map((r) => ({
        slug: toAbs(r.slug),
        tip: toAbs(r.tip),
        benefit: toAbs(r.benefit),
        precaution: toAbs(r.precaution),
        category: toAbs(r.category),
        icon: toAbs(r.icon),
        deeplink: `tulaa://tips/${toAbs(r.slug)}`,
    })).filter(t => t.slug && t.tip && t.benefit);

    // Emit only N_TIPS, shuffled once per day (UTC)
    const daySeed = Number(new Date().toISOString().slice(0, 10).replaceAll('-', ''));
    return seededShuffle(all, daySeed).slice(0, N_TIPS);
}

// ---- Emit
function toTsArray(varName, arr) {
    // Keep valid JSON; TS accepts quoted keys.
    const json = JSON.stringify(arr, null, 2);
    return `export const ${varName} = ${json} as const;`;
}

async function run() {
    const [plans, audios, tips] = await Promise.all([loadPlans(), loadAudios(), loadTips()]);

    const ts = `import type { YogaPlanPreview, GuidedAudioPreview, TipPreview } from './types';

${toTsArray('yogaPlans', plans)}
${toTsArray('guidedAudios', audios)}
${toTsArray('tips', tips)}
`;

    const outDir = path.join(__dirname, '..', 'src', 'data');
    fs.mkdirSync(outDir, { recursive: true });
    fs.writeFileSync(path.join(outDir, 'generated.ts'), outBanner(ts), 'utf8');

    console.log(
        `[fetch-content] Wrote src/data/generated.ts with ${plans.length} plans, ${audios.length} audios, ${tips.length} tips (limited).`
    );
}

run().catch((e) => {
    console.error('[fetch-content] ERROR:', e);
    process.exit(1);
});