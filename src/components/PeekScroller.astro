---
import CTAButton from "./CTAButton.astro";

export interface Item {
  href: string;
  title: string;
  subtitle?: string;
  teaser?: string;
  image?: string;
  emojiFallback?: string;
}

export interface Props {
  title: string;
  subtitle?: string;
  items: Item[];
  ctaHref?: string;
  ctaLabel?: string;
}

const { title, subtitle, items = [], ctaHref, ctaLabel } = Astro.props;

const hasCTA = Boolean(ctaHref && ctaLabel);

// 1. Create a "Circular" illusion by repeating the list multiple times.
const REPEAT_COUNT = 12;
const displayItems = Array(REPEAT_COUNT).fill(items).flat();
// Generate a safe ID for the scroll container
const shelfId = `shelf-${title.replace(/\s+/g, "")}`;
---

{
  items.length > 0 && (
    <section class="shelf-section" aria-label={title}>
      <header class="shelf-header">
        <h2 class="shelf-title">{title}</h2>
        {subtitle && <p class="shelf-subtitle">{subtitle}</p>}
      </header>

      {/* UPDATED: Added data attributes so our script can read them easily.
         We removed the JS variable dependency.
      */}
      <div
        class="shelf-viewport"
        id={shelfId}
        data-item-count={items.length}
        data-repeat-count={REPEAT_COUNT}
      >
        <ul class="shelf-track" role="list">
          {displayItems.map((it, index) => (
            <li class="shelf-item">
              <a href={it.href} class="shelf-card">
                <div class="shelf-media">
                  {it.image ? (
                    <img
                      src={it.image}
                      alt=""
                      loading="lazy"
                      decoding="async"
                      style="opacity: 0"
                      onload="this.style.opacity='1'"
                    />
                  ) : (
                    <div class="shelf-emoji">{it.emojiFallback ?? "ðŸ§˜"}</div>
                  )}
                </div>

                <div class="shelf-content">
                  <h3 class="shelf-card-title">{it.title}</h3>
                  <p class="shelf-card-sub">
                    {it.subtitle || it.teaser || "View plan"}
                  </p>
                </div>
              </a>
            </li>
          ))}
        </ul>
      </div>

      {hasCTA && (
        <div class="shelf-footer">
          <CTAButton
            href={ctaHref!}
            label={ctaLabel!}
            variant="soft"
            size="lg"
          />
        </div>
      )}
    </section>
  )
}

<script>
  // Standard Module Script - runs once on bundle load.
  // We attach the listener to handle every navigation event.
  document.addEventListener("astro:page-load", () => {
    const viewports = document.querySelectorAll<HTMLElement>(".shelf-viewport");

    viewports.forEach((viewport) => {
      // Prevent double-initialization if needed, though usually safe to re-run
      // if (viewport.dataset.scrolled) return;

      const itemCount = Number(viewport.dataset.itemCount || 0);
      const repeatCount = Number(viewport.dataset.repeatCount || 0);

      if (itemCount === 0) return;

      // Daily Random Seeding Logic
      const today = new Date();
      const dateSeed =
        today.getFullYear() * 10000 +
        (today.getMonth() + 1) * 100 +
        today.getDate();

      const pseudoRandom = (seed: number) => {
        let x = Math.sin(seed) * 10000;
        return x - Math.floor(x);
      };

      const middleBatch = Math.floor(repeatCount / 2);
      const randomOffset = Math.floor(pseudoRandom(dateSeed) * itemCount);
      const startIndex = middleBatch * itemCount + randomOffset;

      const cards = viewport.querySelectorAll(".shelf-item");
      const targetCard = cards[startIndex] as HTMLElement;

      if (targetCard) {
        // Calculate Position
        const viewportRect = viewport.getBoundingClientRect();
        const cardRect = targetCard.getBoundingClientRect();
        const offsetFromViewport = cardRect.left - viewportRect.left;

        // Ensure clientWidth is available (it will be, inside astro:page-load)
        const centerOffset =
          (viewport.clientWidth - targetCard.clientWidth) / 2;
        const scrollTarget =
          viewport.scrollLeft + offsetFromViewport - centerOffset;

        // Instant Jump
        viewport.scrollTo({
          left: scrollTarget,
          behavior: "auto",
        });

        // Enable smooth scrolling AFTER the initial jump
        requestAnimationFrame(() => {
          viewport.style.scrollBehavior = "smooth";
          viewport.dataset.scrolled = "true"; // Mark as done
        });
      }
    });
  });
</script>

<style>
  /* --- Section Layout --- */
  .shelf-section {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 24px;
  }

  /* --- Header --- */
  .shelf-header {
    text-align: center;
    padding: 0 16px;
  }

  .shelf-title {
    font-size: var(--fs-h1);
    letter-spacing: -0.01em;
    margin: 0 0 6px;
  }

  .shelf-subtitle {
    margin: 0;
    font-size: var(--fs-body);
    color: var(--muted);
    max-width: 600px;
    margin-inline: auto;
  }

  /* --- Scroll Viewport --- */
  .shelf-viewport {
    width: 100%;
    overflow-x: auto;
    overflow-y: hidden;

    /* Hide scrollbar */
    scrollbar-width: none;
    -webkit-overflow-scrolling: touch;

    /* Controlled by JS (starts auto, becomes smooth) */
    scroll-behavior: auto;

    /* Breathing room for shadows */
    padding: 20px 0 40px;
    margin: -20px 0 -40px;

    /* Gradient Mask for fading edges
    mask-image: linear-gradient(
      to right,
      transparent 0%,
      black 2%,
      black 98%,
      transparent 100%
    );
    -webkit-mask-image: linear-gradient(
      to right,
      transparent 0%,
      black 2%,
      black 98%,
      transparent 100%
    ); */

    /* Enforce snapping */
    scroll-snap-type: x mandatory;
  }

  .shelf-viewport::-webkit-scrollbar {
    display: none;
  }

  /* --- Track --- */
  .shelf-track {
    display: flex;
    gap: 20px;

    /* PADDING LOGIC FOR CENTERING:
       50% of viewport minus half the card width (280px / 2 = 140px).
       This ensures the first item sits perfectly in the center.
    */
    padding-inline: calc(50% - 140px);

    width: max-content;
    margin: 0;
    list-style: none;
    box-sizing: border-box;
  }

  /* --- Items --- */
  .shelf-item {
    flex: 0 0 auto;
    width: 280px;

    /* SNAP LOGIC: Always snap center */
    scroll-snap-align: center;
    scroll-snap-stop: always;
  }

  /* Desktop Adjustments */
  @media (min-width: 600px) {
    .shelf-item {
      width: 320px;
    }
    .shelf-track {
      /* Adjust padding for larger card width (320px / 2 = 160px) */
      padding-inline: calc(50% - 160px);
    }
  }

  /* --- Card Styling --- */
  .shelf-card {
    display: flex;
    flex-direction: column;
    height: 100%;
    background: var(--card);
    border: 1px solid var(--ring);
    border-radius: 20px;
    overflow: hidden;
    text-decoration: none;
    color: inherit;
    transition:
      transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1),
      box-shadow 0.3s cubic-bezier(0.2, 0.8, 0.2, 1),
      border-color 0.2s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.04);
  }

  .shelf-card:hover {
    transform: translateY(-6px);
    box-shadow: var(--elev-2);
    border-color: color-mix(in oklch, var(--accent), transparent 60%);
  }

  .shelf-card:active {
    transform: translateY(-2px);
    transition-duration: 0.1s;
  }

  /* --- Media & Loader --- */

  @keyframes shimmer {
    0% {
      background-position: 200% 0;
    }
    100% {
      background-position: -200% 0;
    }
  }

  .shelf-media {
    aspect-ratio: 3 / 2;
    position: relative;
    overflow: hidden;
    border-bottom: 1px solid color-mix(in oklch, var(--ring), transparent 50%);

    /* Skeleton Loader Background */
    background: linear-gradient(
      90deg,
      var(--bg2) 25%,
      color-mix(in oklch, var(--bg2), white 10%) 37%,
      var(--bg2) 63%
    );
    background-size: 400% 100%;
    animation: shimmer 1.8s ease infinite;
  }

  .shelf-media img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    /* Fade in transition */
    transition:
      transform 0.5s ease,
      opacity 0.6s ease;
  }

  .shelf-card:hover .shelf-media img {
    transform: scale(1.05);
  }

  .shelf-emoji {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 4rem;
    background: linear-gradient(135deg, var(--bg1), var(--bg2));
  }

  /* --- Content --- */
  .shelf-content {
    padding: 16px 20px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    flex: 1;
  }

  .shelf-card-title {
    margin: 0;
    font-size: var(--fs-h2);
    font-size: 1.25rem;
    line-height: 1.3;
    color: var(--fg);
  }

  .shelf-card-sub {
    margin: 0;
    font-size: var(--fs-body-sm);
    color: var(--muted);
    line-height: 1.5;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  /* --- Footer --- */
  .shelf-footer {
    display: flex;
    justify-content: center;
    margin-top: 8px;
  }
</style>
