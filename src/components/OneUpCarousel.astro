---
export interface Item {
  href: string;
  title: string;
  subtitle?: string;
  image?: string;
  emojiFallback?: string;
}

export interface Props {
  title: string;
  subtitle?: string;
  items: Item[];
  ctaHref?: string;
  ctaLabel?: string;
  intervalMs?: number; // autoplay interval
}

const {
  title,
  subtitle,
  items = [],
  ctaHref,
  ctaLabel,
  intervalMs = 5200,
} = Astro.props;
---

{items.length > 0 && (
  <section
    class="oc-wrap"
    data-interval={String(intervalMs)}
    tabindex="0"
    aria-roledescription="carousel"
    aria-label={title}
  >
    <!-- Header (centered) -->
    <header class="oc-header">
      <h2 class="oc-title">{title}</h2>
      {subtitle && <p class="oc-subtitle">{subtitle}</p>}
    </header>

    <!-- Slides: one visible, centered -->
    <ul class="oc-track" role="list">
      {items.map((it, idx) => (
        <li
          class="oc-slide"
          aria-hidden={idx === 0 ? "false" : "true"}
        >
          <a class="oc-card" href={it.href}>
            {it.image ? (
              <img
                class="oc-thumb"
                src={it.image}
                alt={it.title}
                width="128"
                height="72"
                loading="lazy"
              />
            ) : (
              <div class="oc-emoji">{it.emojiFallback ?? "üí°"}</div>
            )}
            <div class="oc-copy">
              <h3 class="oc-h3">{it.title}</h3>
              {it.subtitle && <p class="oc-p">{it.subtitle}</p>}
            </div>
          </a>
        </li>
      ))}
    </ul>

    <!-- CTA moved to bottom (centered) -->
    {ctaHref && ctaLabel && (
      <a class="oc-cta" href={ctaHref}>{ctaLabel}</a>
    )}

    <!-- Controls + dots + progress (stacked & centered) -->
    <div class="oc-controls">
      <div class="oc-dots" role="tablist" aria-label={`${title} slides`}>
        {items.map((_, idx) => (
          <button
            class="oc-dot"
            role="tab"
            aria-selected={idx === 0 ? "true" : "false"}
            aria-label={`Go to slide ${idx + 1}`}
          />
        ))}
      </div>

      <div class="oc-progress" aria-hidden="true">
        <span></span>
      </div>

      <div class="oc-arrows">
        <button type="button" data-prev aria-label="Previous">‚Üê</button>
        <button type="button" data-next aria-label="Next">‚Üí</button>
      </div>
    </div>
  </section>
)}

<!-- Styles (keep in this file) -->
<style>
  /* --- Layout --- */
  .oc-wrap {
    margin: 32px auto;
    padding: 16px;
    max-width: 880px;
    text-align: center;
  }

  .oc-header { margin: 0 0 14px; }
  .oc-title  { margin: 0 0 6px; font-size: clamp(18px, 2.4vw, 22px); }
  .oc-subtitle { margin: 0; color: var(--muted); }

  /* Single-card track, centered */
  .oc-track {
    position: relative;
    list-style: none;
    margin: 0;
    padding: 0;
    min-height: 132px;           /* keeps height stable during fades */
    overflow: hidden;
  }

  /* Slides fill the track; only one interactable */
  .oc-slide {
    position: absolute;
    inset: 0;
    display: grid;
    place-items: center;          /* centers the card */
    padding: 2px;                 /* tiny buffer for focus outlines */
    transition: opacity .55s ease, transform .55s ease, filter .55s ease;
  }

  /* Card */
  .oc-card {
    display: flex;
    align-items: center;
    gap: 12px;
    text-decoration: none;
    color: inherit;

    border: 1px solid var(--ring);
    background: var(--panel);
    border-radius: 14px;
    padding: 14px;

    box-shadow: 0 0 0 rgba(0 0 0 / 0);
    transition: box-shadow .25s ease, transform .25s ease;
    max-width: 100%;
  }
  .oc-card:where(:hover,:focus-visible) {
    box-shadow: 0 6px 18px rgba(0 0 0 / 0.08);
    transform: translateY(-1px);
  }

  .oc-thumb {
    inline-size: 128px;
    block-size: 72px;
    object-fit: cover;
    border-radius: 10px;
  }

  .oc-emoji { font-size: 1.8rem; inline-size: 48px; text-align: center; }
  .oc-copy  { text-align: left; }
  .oc-h3    { margin: 0 0 6px; font-size: 1rem; }
  .oc-p     { margin: 0; color: var(--muted); line-height: 1.3; }

  /* Bottom stack */
  .oc-cta {
    display: inline-block;
    margin-top: 14px;
    font-weight: 600;
    text-decoration: none;
    border: 1px solid var(--ring);
    padding: 8px 12px;
    border-radius: 10px;
    white-space: nowrap;
  }

  .oc-controls {
    display: grid;
    gap: 10px;
    justify-items: center;
    margin-top: 14px;
  }

  .oc-dots { display: flex; gap: 6px; }
  .oc-dot {
    inline-size: 8px;
    block-size: 8px;
    border-radius: 999px;
    border: 1px solid var(--ring);
    background: transparent;
    transition: background .25s ease, transform .25s ease;
  }
  .oc-dot[aria-selected="true"] { background: var(--fg); transform: scale(1.15); }

  .oc-progress {
    width: min(520px, 90%);
    height: 3px;
    background: var(--ring);
    border-radius: 999px;
    overflow: hidden;
  }
  .oc-progress > span {
    display: block;
    height: 100%;
    width: 0%;
    background: var(--fg);
    --dur: 5s;
    transition: width var(--dur) linear;
  }

  .oc-arrows { display: flex; gap: 8px; }
  .oc-arrows > button {
    border: 1px solid var(--ring);
    background: transparent;
    border-radius: 10px;
    padding: 6px 10px;
  }

  /* Visibility animation states */
  .oc-slide[aria-hidden="true"] {
    opacity: 0;
    transform: translateX(16px) scale(.985);
    filter: saturate(.9);
    z-index: 0;
    pointer-events: none;
  }

  .oc-slide[aria-hidden="false"] {
    opacity: 1;
    transform: translateX(0) scale(1);
    filter: saturate(1);
    z-index: 1;
    pointer-events: auto;
  }

  /* Optional: hide arrows on small screens */
  @media (max-width: 560px) { .oc-arrows { display: none; } }
</style>

<!-- Once-only client script (no logs) -->
<script is:inline>
  (() => {
    if (window.__ocInitOnce) return;
    window.__ocInitOnce = true;

    const qsa = (root, sel) => Array.from(root.querySelectorAll(sel));

    function initAll() {
      const wraps = qsa(document, ".oc-wrap");
      if (!wraps.length) {
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", initAll, { once: true });
        } else { setTimeout(initAll, 300); }
        return;
      }

      wraps.forEach((wrap) => {
        const slides = qsa(wrap, ".oc-slide");
        const dots = qsa(wrap, ".oc-dot");
        const prevBtn = wrap.querySelector("[data-prev]");
        const nextBtn = wrap.querySelector("[data-next]");
        const bar = wrap.querySelector(".oc-progress > span");
        const total = slides.length;
        if (total < 1) return;

        const prefersReduced = typeof window.matchMedia === "function" &&
          window.matchMedia("(prefers-reduced-motion: reduce)").matches;

        const rawInterval = wrap.dataset?.interval ?? "5000";
        const INTERVAL = Math.max(1500, parseInt(rawInterval, 10) || 5000);

        let i = 0, timer = null;

        function setActive(next) {
          slides[i]?.setAttribute("aria-hidden", "true");
          dots[i]?.setAttribute("aria-selected", "false");
          i = (next + total) % total;
          slides[i]?.setAttribute("aria-hidden", "false");
          dots[i]?.setAttribute("aria-selected", "true");

          if (!prefersReduced && bar) {
            bar.style.setProperty("--dur", `${INTERVAL / 1000}s`);
            bar.style.width = "0%";
            requestAnimationFrame(() =>
              requestAnimationFrame(() => { bar.style.width = "100%"; })
            );
          }
        }
        function stop() { if (timer !== null) { clearInterval(timer); timer = null; } }
        function start() {
          if (prefersReduced || total < 2) return;
          stop();
          if (bar) bar.style.width = "100%";
          timer = window.setInterval(() => setActive(i + 1), INTERVAL);
        }

        prevBtn?.addEventListener("click", () => { setActive(i - 1); start(); });
        nextBtn?.addEventListener("click", () => { setActive(i + 1); start(); });
        dots.forEach((d, di) => d.addEventListener("click", () => { setActive(di); start(); }));

        wrap.addEventListener("mouseenter", stop);
        wrap.addEventListener("mouseleave", start);
        wrap.addEventListener("focusin", stop);
        wrap.addEventListener("focusout", (e) => {
          const nextTarget = e.relatedTarget;
          if (!nextTarget || !wrap.contains(nextTarget)) start();
        });

        wrap.addEventListener("keydown", (e) => {
          if (e.key === "ArrowRight") { e.preventDefault(); setActive(i + 1); start(); }
          else if (e.key === "ArrowLeft") { e.preventDefault(); setActive(i - 1); start(); }
          else if (e.code === "Space") { e.preventDefault(); timer === null ? start() : stop(); }
        });

        if ("IntersectionObserver" in window) {
          const io = new IntersectionObserver(
            (entries) => entries.some((en) => en.isIntersecting) ? start() : stop(),
            { threshold: 0.1 }
          );
          io.observe(wrap);
        }
        document.addEventListener("visibilitychange", () => {
          document.hidden ? stop() : start();
        });

        // init
        setActive(0);
        start();
      });
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initAll, { once: true });
    } else {
      initAll();
    }
  })();
</script>